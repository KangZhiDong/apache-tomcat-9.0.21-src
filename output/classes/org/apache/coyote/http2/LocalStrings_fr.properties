# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

abstractStream.windowSizeDec=Connection [{0}], Flux [{1}], r\u00e9duction de la fen\u00eatre de contr\u00f4le de flux de [{2}] \u00e0 [{3}]
abstractStream.windowSizeInc=Connection [{0}], Stream [{1}], augmentez la taille de la fen\u00eatre de contr\u00f4le de flux de [{2}] \u00e0 [{3}]
abstractStream.windowSizeTooBig=Connection [{0}], Flux [{1}], L''augmentation de la taille de la fen\u00eatre de [{2}] \u00e0 [{3}] a exc\u00e9d\u00e9 le maximum autoris\u00e9

connectionPrefaceParser.eos=Fin de flux inattendue lors de la lecture de la pr\u00e9face du client, seuls [{0}] octets ont \u00e9t\u00e9 lus
connectionPrefaceParser.ioError=Echec de la lecture des octets de la pr\u00e9face du client
connectionPrefaceParser.mismatch=Une s\u00e9quence inattendue d''octets a \u00e9t\u00e9 recue au d\u00e9but de la pr\u00e9face  client [{0}]

connectionSettings.debug=Connection [{0}], Param\u00e8tre type [{1}] mis \u00e0 [{2}]
connectionSettings.enablePushInvalid=Connection [{0}], La valeur demand\u00e9e pour activer le push [{1}] n''est pas une de celles permises (z\u00e9ro ou un)
connectionSettings.headerTableSizeLimit=La Connection [{0}] a essay\u00e9 de configurer une taille de [{1}] pour la table des en-t\u00eates (headers), mais la limite est 16k
connectionSettings.maxFrameSizeInvalid=Connection [{0}], la taille maximum de trame demand\u00e9e  [{1}] est en-dehors des limites permises [{2}] - [{3}]
connectionSettings.unknown=Connection [{0}], Un param\u00e8tre inconnu avec l''identifiant [{1}] et la valeur [{2}] a \u00e9t\u00e9 ignor\u00e9
connectionSettings.windowSizeTooBig=Connection [{0}], La taille de fen\u00eatre demand\u00e9e [{1}] est plus grande que la valeur maximale autoris\u00e9e [{2}]

frameType.checkPayloadSize=La taille de donn\u00e9es [{0}] n''est pas valide pour une trame de type [{1}]
frameType.checkStream=Type de trame invalide [{0}]

hpack.integerEncodedOverTooManyOctets=Un entier de taille variable de HPACK a \u00e9t\u00e9 encod\u00e9 sur trop d''octets, le maximum est de [{0}]
hpack.invalidCharacter=Le caract\u00e8re Unicode [{0}] ayant le code point [{1}] ne peut \u00eatre encod\u00e9, parce qu''il est en-dehors de l''\u00e9ventail permis 0-255.

hpackEncoder.encodeHeader=Encodage de l''en-t\u00eate [{0}] avec la valeur [{1}]

hpackdecoder.headerTableIndexInvalid=L''index [{0}] dans la table des en-t\u00eates n''est pas valide car il y a [{1}] en-t\u00eates statiques et [{2}] en-t\u00eates dynamiques
hpackdecoder.maxMemorySizeExceeded=La taille de la table des en-t\u00eates [{0}] d\u00e9passe la taille maximale [{1}]
hpackdecoder.notImplemented=Pas encore impl\u00e9ment\u00e9
hpackdecoder.nullHeader=L''en-t\u00eate \u00e0 l''index [{0}] est nul
hpackdecoder.tableSizeUpdateNotAtStart=Toute mise \u00e0 jour de la taille de la table doit \u00eatre faite avant le d\u00e9but d'un bloc d'en-t\u00eates
hpackdecoder.zeroNotValidHeaderTableIndex=Z\u00e9ro n'est pas un index valide dans la table des en-t\u00eates

hpackhuffman.huffmanEncodedHpackValueDidNotEndWithEOS=La valeur encod\u00e9e en Huffman dans les en-t\u00eates HPACK n'avait pas de donn\u00e9es tampon d'EOS
hpackhuffman.stringLiteralTooMuchPadding=Plus de 7 bits de donn\u00e9es tampon de fin de flux ont \u00e9t\u00e9 fournis \u00e0 la fin d'une cha\u00eene encod\u00e9e avec Huffman

http2Parser.error=Connection [{0}], Flux [{1}], Type de trame [{2}], Erreur
http2Parser.headerLimitCount=Connection [{0}], Slux [{1}], Trop d''en-t\u00eates
http2Parser.headerLimitSize=Connection [{0}], Flux [{1}], La taille totale des en-t\u00eates est trop grosse
http2Parser.headers.wrongFrameType=Connection [{0}], Le traitement des en-t\u00eates est en cours pour le flux [{1}] mais une trame de type [{2}] a \u00e9t\u00e9 re\u00e7ue
http2Parser.headers.wrongStream=Connection [{0}], en t\u00eates en cours pour le flux [{1}] mais une trame du flux [{2}] a \u00e9t\u00e9 re\u00e7ue
http2Parser.invalidBuffers=La lecture doit \u00eatre faite avec deux buffers
http2Parser.nonZeroPadding=Connection [{0}], Stream [{1}], rembourrage (padding) non-z\u00e9ro recu
http2Parser.payloadTooBig=La taille des donn\u00e9es est de [{0}] octets mais la taille maximale de la trame est de [{1}]
http2Parser.preface.invalid=Une pr\u00e9face de connection invalide a \u00e9t\u00e9 pr\u00e9sent\u00e9e
http2Parser.preface.io=Impossible de lire la pr\u00e9face de la connection
http2Parser.processFrame=Connection [{0}], Flux [{1}], Type de trame [{2}], Drapeaux [{3}], Taille des donn\u00e9es [{4}]
http2Parser.processFrame.tooMuchPadding=Connection [{0}], Flux [{1}], La taille [{2}] des donn\u00e9es tampon est trop grosse pour la taille de donn\u00e9es [{3}]
http2Parser.processFrame.unexpectedType=Attendu une trame de type [{0}] mais re\u00e7u une trame de type [{1}]
http2Parser.processFrameContinuation.notExpected=Connection [{0}], La trame de continuation a \u00e9t\u00e9 re\u00e7ue pour le flux [{1}] alors qu''aucun trainement d''en-t\u00eates n''\u00e9tait en cours
http2Parser.processFrameData.lengths=Connection [{0}], Flux [{1}], Taille des donn\u00e9es, [{2}], Taille des donn\u00e9es tampon [{3}]
http2Parser.processFrameData.window=Connection [{0}], le client a envoy\u00e9 plus de donn\u00e9es que la "stream window" ne le permet
http2Parser.processFrameGoaway.payloadTooSmall=Connection [{0}]: La taille de donn\u00e9es du Goaway \u00e9tait [{1}] ce qui est moins que le minimum de 8
http2Parser.processFrameHeaders.decodingDataLeft=Des donn\u00e9es restent apr\u00e8s le d\u00e9codage de HPACK, elles auraient d\u00fb \u00eatre consomm\u00e9es
http2Parser.processFrameHeaders.decodingFailed=Une erreur de d\u00e9codage HPACK des en-t\u00eates HTTP s'est produite
http2Parser.processFrameHeaders.payload=Connection [{0}], Flux [{1}], Traitement des en-t\u00eates avec une taille de donn\u00e9es de [{2}]
http2Parser.processFramePing.invalidPayloadSize=Une trame de param\u00e8tres avec une taille de donn\u00e9es invalide de [{0}] a \u00e9t\u00e9 re\u00e7ue (elle devrait \u00eatre de 8)
http2Parser.processFramePriority.invalidParent=Connection [{0}], Flux [{1}], Un flux ne peut pas d\u00e9pendre de lui-m\u00eame
http2Parser.processFramePriority.invalidPayloadSize=Trame prioritaire recue avec une charge utile de taille [{0}] (devrait \u00eatre 5)
http2Parser.processFramePushPromise=Connexion [{0}], Flux (Stream) [{1}], les trames de promesse d''envoi ("Push promise frames") ne doivent pas \u00eatre envoy\u00e9es par le client.
http2Parser.processFrameSettings.ackWithNonZeroPayload=La trame de param\u00e8tres a \u00e9t\u00e9 re\u00e7ue avec un indicateur ACK activ\u00e9 et des donn\u00e9es pr\u00e9sentes
http2Parser.processFrameSettings.invalidPayloadSize=La trame de param\u00e8tres a \u00e9t\u00e9 re\u00e7ue avec une taille de donn\u00e9es de [{0}] qui n''est pas un multiple de 6
http2Parser.processFrameWindowUpdate.debug=Connection [{0}], Flux [{1}], Incr\u00e9mentation de [{2}] de la taille de fen\u00eatre
http2Parser.processFrameWindowUpdate.invalidIncrement=La trame de mise \u00e0 jour de la fen\u00eatre a \u00e9t\u00e9 re\u00e7ue avec un incr\u00e9ment invalide [{0}]
http2Parser.processFrameWindowUpdate.invalidPayloadSize=La trame de mise \u00e0 jour de la fen\u00eatre a \u00e9t\u00e9 re\u00e7ue avec une taille de donn\u00e9es invalide de [{0}]
http2Parser.swallow.debug=Connection [{0}], Flux [{1}], Aval\u00e9 [{2}] octets

pingManager.roundTripTime=Connection [{0}] Le temps d''aller retour est de [{1}]ns

stream.closed=Connection [{0}], Flux [{1}], Impossible d''\u00e9crire sur un flux apr\u00e8s sa fermeture
stream.header.case=Connection [{0}], Flux [{1}], Le nom d''en-t\u00eate HTTP [{2}] doit \u00eatre en miniscules
stream.header.connection=Connection [{0}], Flux [{1}], L''en-t\u00eate HTTP [connection] n''est pas autoris\u00e9 dans une requ\u00eate HTTP/2
stream.header.contentLength=Connection [{0}], Flux [{1}], La valeur de l''en-t\u00eate content-length [{2}] ne correspond pas \u00e0 la taille des donn\u00e9es re\u00e7ue [{3}]
stream.header.debug=Connection [{0}], Flux [{1}], en-t\u00eate HTTP [{2}], valeur [{3}]
stream.header.duplicate=Connection [{0}], Flux [{1}], Re\u00e7u plusieurs en-t\u00eates [{3}]
stream.header.empty=Connection [{0}], Flux [{1}], Le nom d''en-t\u00eate nul est invalide
stream.header.invalid=Connection [{0}], Flux [{1}], L''en-t\u00eate[{2}] contenait la valeur invalide [{3}]
stream.header.noPath=Connection [{0}], flux [{1}], Le [:path] pseudo en-t\u00eate est vide
stream.header.required=Connection [{0}], Flux [{1}], Un ou plusieurs en-t\u00eates n\u00e9cessaires sont manquants
stream.header.te=Connection [{0}], Flux [{1}], L''en-t\u00eate HTTP [te] n''est pas autoris\u00e9 avec la valeur [{2}] dans une requ\u00eate HTTP/2
stream.header.unexpectedPseudoHeader=Connection [{0}], Flux [{1}], Le pseudo en-t\u00eate [{2}] a \u00e9t\u00e9 re\u00e7u apr\u00e8s un en-t\u00eate normal
stream.header.unknownPseudoHeader=Connection [{0}], Flux [{1}], Un pseudo en-t\u00eate inconnu [{2}] a \u00e9t\u00e9 re\u00e7u
stream.inputBuffer.copy=Copide de [{0}] octets depuis inBuffer vers outBuffer
stream.inputBuffer.dispatch=Des donn\u00e9es on \u00e9t\u00e9 ajout\u00e9es dans inBuffer alors que la lecture est surveill\u00e9e, envoi d'un \u00e9v\u00e8nement de lecture
stream.inputBuffer.empty=Le tampon d'entr\u00e9e du flux est vide, attente de donn\u00e9es
stream.inputBuffer.readTimeout=D\u00e9lai d'attente maximum d\u00e9pass\u00e9 pendant la lecture des donn\u00e9es du client
stream.inputBuffer.reset=Flux r\u00e9initialis\u00e9
stream.inputBuffer.signal=Des donn\u00e9es ont \u00e9t\u00e9 ajout\u00e9es dans inBuffer alors que le thread de lecture attend, cela lui sera signal\u00e9
stream.notWritable=Connection [{0}], Flux [{1}], Impossible d''\u00e9crire sur ce flux
stream.outputBuffer.flush.debug=Connection [{0}], Flux [{1}], envoi des donn\u00e9es mises en tampon depuis la position [{2}], writeInProgress [{3}] et closed [{4}]
stream.reprioritisation.debug=Connection [{0}], Flux [{1}], Exclusive [{2}], Parent [{3}], Poids [{4}]
stream.reset.fail=Connection [{0}], Flux [{1}], Echec de r\u00e9initialisation du flux
stream.reset.receive=Connection [{0}], Flux [{1}], R\u00e9initialisation re\u00e7ue \u00e0 cause de [{2}]
stream.reset.send=Connection [{0}], Flux [{1}], R\u00e9initialisation envoy\u00e9e \u00e0 cause de [{2}]
stream.trailerHeader.noEndOfStream=Connection [{0}], Flux [{1}], Les en-t\u00eates de fin n''incluent pas l''indicateur de fin de flux
stream.writeTimeout=Temps d'attente maximum du client d\u00e9pass\u00e9 pour augmenter la fen\u00eatre de contr\u00f4le de flux pour permettre l'\u00e9criture de donn\u00e9es

streamProcessor.cancel=Connection [{0}], Flux [{1}], Le reste du corps de la requ\u00eate n''est pas n\u00e9cessaire
streamProcessor.error.connection=Connection [{0}], Stream [{1}], Une erreur s''est produite dans le traitement, fatale pour la connection
streamProcessor.error.stream=Connection [{0}], Flux [{1}], Une erreur d''est produite durant le traitement qui a \u00e9t\u00e9 fatale au flux
streamProcessor.flushBufferedWrite.entry=Connection [{0}], Flux [{1}], Envoi des \u00e9critures mises en tampon
streamProcessor.service.error=Erreur durant le traitement de la requ\u00eate

streamStateMachine.debug.change=Connection [{0}], Flux [{1}], L\u2019\u00e9tat a chang\u00e9 de [{2}] vers [{3}]
streamStateMachine.invalidFrame=Connection [{0}], Flux [{1}], Etat [{2}], Type de trame [{3}]
streamStateMachine.invalidReset=Connection [{0}], Stream [{1}], Etat [{2}], Reset n''est pas permitted dans cet Etat

upgradeHandler.allocate.debug=Connection [{0}], Flux [{1}], [{2}] octets allou\u00e9s
upgradeHandler.allocate.left=Connection [{0}], Flux [{1}], [{2}] octets d\u00e9sallou\u00e9s, essai d''allocation aux enfants
upgradeHandler.allocate.recipient=Connection [{0}], Flux [{1}], receveur potentiel [{2}] avec poids [{3}]
upgradeHandler.connectionError=Erreur de la connection
upgradeHandler.dependency.invalid=Connection [{0}], Flux [{1}], Un flux ne peut d\u00e9pendre de lui-m\u00eame
upgradeHandler.goaway.debug=Connection [{0}], Goaway, Dernier flux [{1}], Code d''erreur [{2}], Donn\u00e9es de d\u00e9bogage [{3}]
upgradeHandler.init=Connection [{0}], Etat [{1}]
upgradeHandler.initialWindowSize.invalid=Connection [{0}], La valeur [{1}] initiale de la taille de fen\u00eatre est invalide
upgradeHandler.invalidPreface=Connection [{0}], Pr\u00e9face de connection invalide
upgradeHandler.ioerror=Connection [{0}]
upgradeHandler.noAllocation=Connection [{0}], Flux [{1}], Temps d''attente maximum d\u00e9pass\u00e9 lors de l''allocation
upgradeHandler.noNewStreams=Connection [{0}], Flux [{1}], Flux ignor\u00e9 car aucun nouveau flux n''est autoris\u00e9 sur cette connection
upgradeHandler.pause.entry=Connection [{0}] mise en pause
upgradeHandler.pingFailed=La connection [{0}] a \u00e9chou\u00e9 \u00e0 envoyer un ping au client
upgradeHandler.prefaceReceived=Connection [{0}], pr\u00e9face de la connection recue du client
upgradeHandler.pruneIncomplete=Connexion [{0}], Flux [{1}], Erreur lors de l''\u00e9limination compl\u00e8te de la connexion parce que des flux sont encore actifs / utilis\u00e9s dans l''arbre de priorit\u00e9, il y a [{2}] flux en trop
upgradeHandler.pruneStart=Connection [{0}] D\u00e9but de l''\u00e9limination des anciens flux, la limite est de [{1}] + 10% et il y a actuellement [{2}] flux
upgradeHandler.pruned=Connection [{0}] Elimination du flux termin\u00e9 [{1}]
upgradeHandler.prunedPriority=La connexion [{0}] a \u00e9lagu\u00e9 le flux inutilis\u00e9 [{1}] qui faisait peut-\u00eatre partie de l''arbre de priorit\u00e9
upgradeHandler.releaseBacklog=Connection [{0}], Flux [{1}] enlev\u00e9e de la file d''attente
upgradeHandler.rst.debug=Connexion [{0}], Flux [{1}], Erreur [{2}], Message [{3}], RST (fermeture du flux)
upgradeHandler.sendPrefaceFail=Connexion [{0}], \u00e9chec d''envoi de la pr\u00e9face au client
upgradeHandler.socketCloseFailed=Echec de la fermeture du socket
upgradeHandler.stream.closed=Le flux [{0}] a d\u00e9j\u00e0 \u00e9t\u00e9 ferm\u00e9 auparavant
upgradeHandler.stream.even=Un nouvel ID de flux distant (remote stream) [{0}] a \u00e9t\u00e9 requis, mais tous les flux distants doivent utiliser ID impairs
upgradeHandler.stream.notWritable=Connection [{0}], Flux [{1}], Impossible d''\u00e9crire sur ce flux
upgradeHandler.stream.old=Un nouveau flux distant avec l''ID [{0}] a \u00e9t\u00e9 demand\u00e9 mais le flux le plus r\u00e9cent est [{1}]
upgradeHandler.tooManyRemoteStreams=Le client a essay\u00e9 d''utiliser plus de [{0}] flux actifs
upgradeHandler.tooMuchOverhead=Connection [{0}], Le traitement est trop co\u00fbteux donc la connection sera ferm\u00e9e
upgradeHandler.unexpectedAck=Connection [{0}], Flux [{1}], Une notification de r\u00e9ception de param\u00e8tres a \u00e9t\u00e9 re\u00e7ue alors qu''aucune n''\u00e9tait attendue
upgradeHandler.unexpectedEos=Fin de flux inattendue
upgradeHandler.upgrade=Connexion [{0}], HTTP/1.1 transform\u00e9e en flux [1]
upgradeHandler.upgrade.fail=Connection [{0}], Echec de l''upgrade de HTTP/1.1
upgradeHandler.upgradeDispatch.entry=Entr\u00e9e, Connection [{0}], SocketStatus [{1}]
upgradeHandler.upgradeDispatch.exit=Sortie, Connection [{0}], SocketState [{1}]
upgradeHandler.windowSizeReservationInterrupted=Connection [{0}], Flux [{1}], r\u00e9serv\u00e9 [{2}] octets
upgradeHandler.windowSizeTooBig=Connection [{0}], Flux [{1}], La taille de la fen\u00eatre est trop grosse
upgradeHandler.writeBody=Connection [{0}], Flux [{1}], Taille des donn\u00e9es [{2}]
upgradeHandler.writeHeaders=Connection [{0}], Stream [{1}]
upgradeHandler.writePushHeaders=Connection [{0}], Flux [{1}], Flux de push [{2}], EndOfStream [{3}]

writeStateMachine.endWrite.ise=il est ill\u00e9gal de sp\u00e9cifier [{0}] pour le nouvel \u00e9tat d\u00e8s lors qu''une \u00e9criture s''est termin\u00e9e
writeStateMachine.ise=Il est ill\u00e9gal d'appeler [{0}()] dans l'\u00e9tat [{1}]
